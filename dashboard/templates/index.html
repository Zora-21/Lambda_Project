<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dashboard Avanzata - Analisi Crypto</title>
    
    <style>
        body { 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: #f4f7f6;
            margin: 0;
            padding: 20px;
        }
        
        .container {
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 20px;
            /* --- INIZIO MODIFICA: Larghezza ridotta di 5px --- */
            max-width: 1795px; 
            /* --- FINE MODIFICA --- */
            margin: 0 auto;
        }
        .left-column {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        .chart-stack {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        .card {
            background-color: #ffffff;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.05);
            padding: 20px;
            display: flex;
            flex-direction: column;
        }
        .card h2 {
            border-bottom: 2px solid #eee;
            padding-bottom: 10px;
            margin-top: 0;
            font-size: 1.25em;
        }
        .card h3 {
            margin-top: 0;
            margin-bottom: 12px;
            font-size: 1.1em;
            color: #555;
        }
        .chart-container {
            flex-grow: 1;
            position: relative;
            min-height: 250px; 
        }
        
        #header-card {
            padding: 20px;
        }
        #header-card h2 {
            text-align: center;
            border-bottom: none;
            margin-bottom: 15px;
        }
        .header-controls-inner {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
        }
        .header-controls-inner label {
            font-size: 1.1em;
            font-weight: 500;
        }
        .header-controls-inner select {
            font-size: 1em;
            padding: 8px;
            border-radius: 6px;
            border: 1px solid #ccc;
        }

        .top-row-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        .top-row-grid .card {
            box-shadow: none; 
            padding: 0;
        }
        .top-row-grid .card h2 {
            padding: 20px 20px 10px 20px;
        }
        #sensor-status, #job-control {
            padding: 0 20px 20px 20px;
        }

        /* Metriche Cards */
        .metrics-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-top: 10px;
        }
        .metric-box {
            background: #f8f9fa;
            padding: 12px;
            border-radius: 6px;
            border-left: 4px solid #007bff;
        }
        .metric-box.positive {
            border-left-color: #28a745;
        }
        .metric-box.negative {
            border-left-color: #dc3545;
        }
        /* --- INIZIO MODIFICA: Stili aggiunti per la card scarti --- */
        .metrics-grid-3col {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 12px;
            margin-top: 10px;
        }
        .metric-box.warning {
            border-left-color: #ffc107;
        }
        .metric-box.danger {
            border-left-color: #dc3545;
        }
        /* --- FINE MODIFICA --- */
        .metric-label {
            font-size: 0.85em;
            color: #666;
            margin-bottom: 4px;
        }
        .metric-value {
            font-size: 1.3em;
            font-weight: bold;
            color: #333;
        }
        .metric-value.positive {
            color: #28a745;
        }
        .metric-value.negative {
            color: #dc3545;
        }
        
        /* Stato sensore */
        #sensor-status p { margin: 10px 0; font-size: 1.1em; }
        .status-online { color: #28a745; font-weight: bold; }
        .status-offline { color: #dc3545; font-weight: bold; }
        .status-no_data { color: #888; font-style: italic; }
        
        /* Pulsante job */
        #run-job-btn {
            width: 100%; 
            padding: 12px; 
            font-size: 16px; 
            margin-top: 10px; 
            background-color: #007bff; 
            color: white; 
            border: none; 
            border-radius: 5px; 
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        #run-job-btn:hover { background-color: #0056b3; }
        #run-job-btn:disabled { background-color: #cccccc; cursor: not-allowed; }
        
        #job-trigger-status { 
            text-align: center; 
            margin-top: 10px; 
            font-size: 0.9em; 
        }
        
    </style>

    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
</head>
<body>

    <div class="container">
        <div class="left-column">
            
            <div class="card" id="header-card">
                <h2>üìä Dashboard Analisi Crypto Avanzata</h2>
                <div class="header-controls-inner">
                    <label for="sensor-select">Seleziona Simbolo:</label>
                    <select id="sensor-select">
                        <option value="A1" selected>BTC/USDT (A1)</option>
                        <option value="B1">ETH/USDT (B1)</option>
                        <option value="C1">SOL/USDT (C1)</option>
                    </select>
                </div>
            </div>
            
            <div class="card" style="padding: 0;"> <div class="top-row-grid">
                    <div class="card">
                        <h2>‚ö° Stato Real-Time</h2>
                        <div id="sensor-status">
                            <p id="status-label">Simbolo A1: In attesa...</p>
                            <p id="status-temp">Prezzo: N/A</p>
                        </div>
                    </div>
                    
                    <div class="card">
                        <h2>‚öôÔ∏è Controllo Batch</h2>
                        <div id="job-control">
                            <button id="run-job-btn">Avvia Job MapReduce</button>
                            <p id="job-trigger-status"></p>
                        </div>
                    </div>
                </div>
            </div>

            <div class="card">
                <h2>üìà Metriche Giornaliere (Batch)</h2>
                <div id="daily-metrics">
                    <p style="text-align: center; color: #888;">Caricamento...</p>
                </div>
            </div>
            
            <div class="card">
                <h2>üóëÔ∏è Dati Scartati (Anomalie)</h2>
                <div id="discard-stats">
                    <div class="metrics-grid-3col">
                        <div class="metric-box warning">
                            <div class="metric-label">Job Precedente</div>
                            <div class="metric-value" id="discard-previous">0</div>
                        </div>
                        <div class="metric-box warning">
                            <div class="metric-label">Job Corrente</div>
                            <div class="metric-value" id="discard-current">0</div>
                        </div>
                        <div class="metric-box danger">
                            <div class="metric-label">Totale Scarti</div>
                            <div class="metric-value" id="discard-total">0</div>
                        </div>
                    </div>
                </div>
            </div>
            </div>

        <div class="chart-stack">
            <div class="card">
                <h2>üî¥ Trend Real-Time (Speed Layer)</h2>
                <div class="chart-container" style="min-height: 300px;">
                    <canvas id="realtimeLineChart"></canvas>
                </div>
            </div>
            
            <div class="card">
                <h2>üöÄ Performance: Uso Memoria (RAM)</h2>
                <div class="chart-container">
                    <canvas id="memoryChart"></canvas>
                </div>
            </div>
            
            <div class="card">
                <h2>üåê Performance: Traffico di Rete (I/O)</h2>
                <div class="chart-container">
                    <canvas id="networkChart"></canvas>
                </div>
            </div>
            
        </div>
    </div>

    <script>
        let realtimeLineChartInstance;
        let memoryChartInstance;
        let networkChartInstance;
        let batchPollInterval;

        const SENSOR_DETAILS = {
            'A1': { name: 'BTC/USDT', color: 'rgba(242, 169, 0, 1)' },
            'B1': { name: 'ETH/USDT', color: 'rgba(98, 126, 234, 1)' },
            'C1': { name: 'SOL/USDT', color: 'rgba(153, 69, 255, 1)' }
        };

        // --- Inizializzazione Grafici (invariata) ---

        function initializeRealtimeLineChart() {
            const ctx = document.getElementById('realtimeLineChart').getContext('2d');
            realtimeLineChartInstance = new Chart(ctx, {
                type: 'line', 
                data: {
                    datasets: [{ 
                        label: 'Prezzo (USD)', 
                        data: [], 
                        borderColor: 'rgba(0, 123, 255, 1)', 
                        tension: 0.1,
                        pointRadius: 0,
                        fill: true, 
                        borderWidth: 2 
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: { 
                            title: { display: true, text: 'Prezzo (USD)' },
                            beginAtZero: false, 
                            ticks: { callback: v => '$' + v.toLocaleString() }
                        },
                        x: {
                           type: 'time', 
                           time: {
                                unit: 'hour',
                                stepSize: 1, 
                                tooltipFormat: 'HH:mm',
                                displayFormats: {
                                    hour: 'HH:00'
                                }
                           },
                           title: { display: true, text: 'Tempo' },
                           min: new Date().getTime(), 
                           max: new Date().getTime() + 12 * 60 * 60 * 1000 
                        }
                    },
                    animation: { duration: 0 } 
                }
            });
        }
        
        function createBarChart(canvasId, yAxisLabel) {
            const ctx = document.getElementById(canvasId).getContext('2d');
            return new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: [], // Nomi container
                    datasets: []  // Dati
                },
                options: {
                    indexAxis: 'y', // Grafico orizzontale
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            beginAtZero: true,
                            title: { display: true, text: yAxisLabel },
                            stacked: true // Stack per Rete (Rx/Tx)
                        },
                        y: {
                            ticks: { autoSkip: false },
                            stacked: true
                        }
                    },
                    plugins: {
                        legend: {
                            display: true
                        }
                    }
                }
            });
        }

        function initializePerformanceCharts() {
            // 1. Grafico Memoria
            memoryChartInstance = createBarChart('memoryChart', 'Memoria (MB)');
            memoryChartInstance.data.datasets = [{
                label: 'Uso Memoria (MB)',
                data: [],
                backgroundColor: 'rgba(0, 123, 255, 0.6)',
            }];
            
            // 2. Grafico Rete
            networkChartInstance = createBarChart('networkChart', 'Traffico di Rete (MB)');
            networkChartInstance.data.datasets = [
                {
                    label: 'Ricevuti (Rx)',
                    data: [],
                    backgroundColor: 'rgba(40, 167, 69, 0.6)',
                },
                {
                    label: 'Inviati (Tx)',
                    data: [],
                    backgroundColor: 'rgba(255, 193, 7, 0.6)',
                }
            ];
        }
        
        // --- Aggiornamento Dati ---

        async function updateRealtimeData(sensorId) {
            const sensorConfig = SENSOR_DETAILS[sensorId];
            
            try {
                const response = await fetch(`/data/realtime?sensor_id=${sensorId}`); 
                const data = await response.json();
                
                const statusEl = document.getElementById('status-label');
                const tempEl = document.getElementById('status-temp');

                if (data.status) {
                    statusEl.innerHTML = `Simbolo ${sensorId}: 
                        <span class="status-${data.status.toLowerCase()}">${data.status}</span>`;
                    
                    let tempText = (data.temp !== 'N/A') ? '$' + parseFloat(data.temp).toLocaleString() : 'N/A';
                    tempEl.textContent = `Prezzo: ${tempText}`;
                }
            } catch (error) {
                console.error('Errore fetch realtime:', error);
            }
            
            try {
                const response = await fetch(`/data/realtime/trend?sensor_id=${sensorId}`);
                const data = await response.json(); // Ora restituisce {data, time_min, time_max}
                
                if (realtimeLineChartInstance) {
                    const dataset = realtimeLineChartInstance.data.datasets[0];
                    dataset.data = data.data; 
                    dataset.label = `Prezzo ${sensorConfig.name}`;
                    
                    const baseColor = sensorConfig.color;
                    dataset.borderColor = baseColor;
                    
                    const ctx = realtimeLineChartInstance.ctx;
                    const gradient = ctx.createLinearGradient(0, 0, 0, ctx.canvas.height);
                    gradient.addColorStop(0, baseColor.replace('1)', '0.5)')); 
                    gradient.addColorStop(1, baseColor.replace('1)', '0)'));   
                    dataset.backgroundColor = gradient; 
                    
                    realtimeLineChartInstance.options.scales.x.min = data.time_min;
                    realtimeLineChartInstance.options.scales.x.max = data.time_max;

                    realtimeLineChartInstance.update('none');
                }
            } catch (error) {
                console.error('Errore fetch /data/realtime/trend:', error);
            }
        }

        async function updateBatchData(sensorId) {
            try {
                const response = await fetch(`/data/batch?sensor_id=${sensorId}`);
                const data = await response.json();

                if (data.status) {
                    return false;
                }
                
                const dates = Object.keys(data);
                if (dates.length === 0) {
                    return false;
                }
                
                // Aggiorna metriche giornaliere (ultima data)
                const latestDate = dates[dates.length - 1];
                const latestMetrics = data[latestDate];
                updateDailyMetrics(latestMetrics, latestDate);

                // --- INIZIO MODIFICA: Rimuovi chiamata a loadBatchSummary ---
                // loadBatchSummary(sensorId); // Questa funzione non esiste pi√π
                // --- FINE MODIFICA ---

                return true;

            } catch (error) {
                console.error('Errore fetch batch:', error);
                return false;
            }
        }

        function updateDailyMetrics(metrics, date) {
            const container = document.getElementById('daily-metrics');
            
            const changeClass = metrics.daily_change >= 0 ? 'positive' : 'negative';
            const changeSign = metrics.daily_change >= 0 ? '+' : '';
            
            container.innerHTML = `
                <div style="text-align: center; margin-bottom: 15px; color: #666; font-size: 0.9em;">
                    ${date}
                </div>
                <div class="metrics-grid">
                    <div class="metric-box">
                        <div class="metric-label">Open</div>
                        <div class="metric-value">$${metrics.open.toLocaleString()}</div>
                    </div>
                    <div class="metric-box">
                        <div class="metric-label">Close</div>
                        <div class="metric-value">$${metrics.close.toLocaleString()}</div>
                    </div>
                    <div class="metric-box ${changeClass}">
                        <div class="metric-label">Variazione</div>
                        <div class="metric-value ${changeClass}">
                            ${changeSign}${metrics.daily_change_pct.toFixed(2)}%
                        </div>
                    </div>
                    <div class="metric-box">
                        <div class="metric-label">Volatilit√†</div>
                        <div class="metric-value">${metrics.volatility.toFixed(2)}%</div>
                    </div>
                    <div class="metric-box">
                        <div class="metric-label">Min</div>
                        <div class="metric-value">$${metrics.min.toLocaleString()}</div>
                    </div>
                    <div class="metric-box">
                        <div class="metric-label">Max</div>
                        <div class="metric-value">$${metrics.max.toLocaleString()}</div>
                    </div>
                    <div class="metric-box">
                        <div class="metric-label">Range</div>
                        <div class="metric-value">${metrics.range_pct.toFixed(2)}%</div>
                    </div>
                    <div class="metric-box">
                        <div class="metric-label">Osservazioni Pulite</div>
                        <div class="metric-value">${metrics.count}</div>
                    </div>
                </div>
            `;
        }

        // --- INIZIO MODIFICA: Funzione loadBatchSummary ELIMINATA ---
        
        // --- INIZIO MODIFICA: Nuova funzione per Scarti ---
        async function updateDiscardStats() {
            try {
                const response = await fetch('/data/discard_stats');
                const data = await response.json();

                // Aggiorna i 3 contatori
                document.getElementById('discard-previous').textContent = data.previous.toLocaleString();
                document.getElementById('discard-current').textContent = data.current.toLocaleString();
                document.getElementById('discard-total').textContent = data.total.toLocaleString();
            } catch (error) {
                console.error('Errore fetch /data/discard_stats:', error);
                // In caso di errore, mostra 0
                document.getElementById('discard-previous').textContent = '0';
                document.getElementById('discard-current').textContent = '0';
                document.getElementById('discard-total').textContent = '0';
            }
        }
        // --- FINE MODIFICA ---
        
        async function updatePerformanceData() {
            try {
                const response = await fetch('/data/performance');
                const data = await response.json();
                
                if (data.error) {
                    console.error(data.error);
                    return;
                }

                const labels = Object.keys(data).sort();
                
                // 1. Dati Memoria
                if (memoryChartInstance) {
                    memoryChartInstance.data.labels = labels;
                    memoryChartInstance.data.datasets[0].data = labels.map(l => data[l].mem_mb);
                    memoryChartInstance.update('none');
                }
                
                // 2. Dati Rete
                if (networkChartInstance) {
                    networkChartInstance.data.labels = labels;
                    networkChartInstance.data.datasets[0].data = labels.map(l => data[l].net_rx_mb); // Rx
                    networkChartInstance.data.datasets[1].data = labels.map(l => data[l].net_tx_mb); // Tx
                    networkChartInstance.update('none');
                }

            } catch (error) {
                console.error('Errore fetch /data/performance:', error);
            }
        }

        function updateDashboard() {
            const selectedSensor = document.getElementById('sensor-select').value;
            updateRealtimeData(selectedSensor);
            updateBatchData(selectedSensor);
            updatePerformanceData(); 
            updateDiscardStats(); // <-- Aggiunto
        }

        // --- Inizializzazione ---
        window.onload = () => {
            initializeRealtimeLineChart();
            initializePerformanceCharts(); 
            
            updateDashboard();
            
            setInterval(() => {
                const selectedSensor = document.getElementById('sensor-select').value;
                updateRealtimeData(selectedSensor);
                updatePerformanceData();
                updateDiscardStats(); // <-- Aggiunto
            }, 2000); // Intervallo originale di 2 secondi

            document.getElementById('sensor-select').onchange = updateDashboard;

            // Logica pulsante job (invariata)
            const runJobBtn = document.getElementById('run-job-btn');
            const jobStatusEl = document.getElementById('job-trigger-status');

            runJobBtn.onclick = async () => {
                if (batchPollInterval) clearInterval(batchPollInterval);
                jobStatusEl.textContent = 'Avvio del job...';
                runJobBtn.disabled = true;

                try {
                    const response = await fetch('/trigger-job', { method: 'POST' });
                    const data = await response.json();
                    if (!response.ok) throw new Error(data.error || "Errore sconosciuto");

                    jobStatusEl.textContent = 'Job avviato. In attesa risultati...';

                    batchPollInterval = setInterval(async () => {
                        console.log("Polling risultati batch...");
                        const selectedSensor = document.getElementById('sensor-select').value;
                        const success = await updateBatchData(selectedSensor);
                        
                        if (success) {
                            console.log("Dati batch pronti!");
                            clearInterval(batchPollInterval);
                            jobStatusEl.textContent = 'Job completato! ‚úì';
                            runJobBtn.disabled = false;
                            setTimeout(() => { jobStatusEl.textContent = ''; }, 4000);
                        }
                    }, 5000);

                } catch (error) {
                    console.error('Errore trigger-job:', error);
                    jobStatusEl.textContent = `Errore: ${error.message}`;
                    runJobBtn.disabled = false;
                }
            };
        };
    </script>
</body>
</html>